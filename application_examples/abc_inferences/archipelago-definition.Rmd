---
title: "Definition of Archipelagos"
author: "Sara"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries, warning=FALSE, message=FALSE, echo=FALSE}
# If missing, install required packages

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("rtracklayer", quietly = TRUE)) {
  BiocManager::install("rtracklayer")
}

library(rtracklayer)
```

# Archipelago definition

We define archipelagos as genomic regions containing clusters of CGIs. We can interpret archipelagos as regions of the genome larger than CGI that together may regulate a gene or set of genes. Therefore, an approach to define archipelagos can be to choose thresholds that lead to clustering CGI in a way so that each archipelago overlaps with a promoter region (or maximizes cases of overlap single-archipelago and promoter).

Our approach then has the following steps:

1. Definition of promoter regions.
2. Filtering of CGI by promoter overlap.

We will perform this steps for the genomic region of interest:

```{r set region values}
dpp4_chr <- "NC_036801.1"
dpp4_start <- 29502362
dpp4_end <- 29517382
region_start <- dpp4_start - 5e5
region_end <- dpp4_end + 5e5
```

- DPP4 gene location:

  - Chromosome: NC_036801.1
  
      - Start: 29,502,362
      
      - End: 29,517,382
        
- Extended Region: Includes 500,000 base pairs upstream and downstream of the DPP4 gene.


## Step 1: Definition of "promoter/upstream" regions

As in [@vernaz2022epigenetic], since no functional annotation exists for Lake Malawi cichlid genomes, we define promoter regions in silico as regions Â±1 kbp around the TSS.


### Choice of gene annotiation file format

File formats from [NCBI](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000238955.4/). Selected RefSeq only (no Ensembl annotation). More info [here](https://www.biobam.com/differences-between-gtf-and-gff-files-in-genomic-data-analysis/), [here](http://www.ensembl.org/info/website/upload/gff.html) and [here](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-020-6707-9). 


- The General Feature Format (GFF): GFF is a standard file format used for storing genomic sequences and annotations, developed by the Sanger Centre (v2) and the Sequence Ontology Project (v3). It describes features and annotations of DNA, RNA, and protein sequences in a plain text format with nine fields separated by tabs. Focuses on the hierarchical structure of genome annotations and is often less verbose.

- The Gene Transfer Format (GTF): GTF, often seen as a derivative of GFF, is more specific in its application. It was generally termed GTF around 2000 and developed as part of collaborative genome annotation projects. GTF borrows from GFF but has additional structures for detailed gene annotations, often used to describe transcripts and their coding sequences.

The `.gtf` file contains more information, but for our purpose we can use the `.gff` file.

```{r load gff}
# Load the GFF file
gff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gff" 
gff <- as.data.frame(import(gff_file))
names(gff)
```

- `seqnames`: Chromosome.

- `start`, `end`: Coordinates of the gene.

- `strand`: Gene orientation.

- `type`: Feature type (here filtered for genes).

- `Gene`: Gene name or ID.

- `gene_biotype`: Functionality (e.g., protein_coding)

Lets keep the relevant columns:

```{r gff filter relevant columns}
gff <- gff[,c("seqnames", "start", "end", "width", "strand", "type", "source", "ID", "Dbxref", "gene")]
```


```{r gff table of annotation type}
table(gff$type)
```

```{r gff table of annotation source}
table(gff$source)
```

- `source`: indicates the source of the annotation for each feature in the file. These sources represent the tools, pipelines, or databases that generated the corresponding annotation.

  - `RefSeq`: These annotations come directly from the RefSeq database. RefSeq annotations are high-quality, manually curated or computationally derived features that are part of NCBI's Reference Sequence project. Examples: Protein-coding genes, RNA genes, pseudogenes.

   - `Gnomon`: Gnomon is NCBI's gene prediction tool, which generates computationally predicted annotations. These annotations may include protein-coding genes, non-coding RNAs, or other features predicted based on sequence analysis. Gnomon is used when there is no manually curated annotation available for certain regions or genes.

   - `cmsearch`: This refers to the Infernal package (specifically the cmsearch tool), which identifies RNA features such as non-coding RNAs or structured RNA elements.  Often used for annotating RNA families based on covariance models.

  - `tRNAscan-SE`: tRNAscan-SE is a specialized tool for identifying and annotating tRNA genes in genome sequences. Annotations with this source indicate regions identified as tRNAs through this tool.

   - `BestRefSeq`: Features with this source are part of the BestRefSeq annotation, which integrates high-quality manual curation with computational predictions to produce a "best" annotation for a gene or transcript. BestRefSeq annotations are typically the most reliable.

  - BestRefSeq,Gnomon (or `BestRefSeq%2CGnomon`): This indicates that a feature is annotated by both the BestRefSeq and Gnomon pipelines. Such annotations may combine curated data with computational predictions.

### Filter genes of whole genome

First, we filter the GFF file to keep only genes.
```{r filter gff genome}
genome_gff <- gff[
  gff$type == "gene", 
]
```

We can check the source of the filtered annotations:
```{r gff_genome table of annotation source}
table(genome_gff$source)
```

And the number of genes:

```{r gff_genome number of genes}
nrow(genome_gff)
length(unique(genome_gff$ID))
```

We order the entries:

```{r order genome_gff}
genome_gff <- genome_gff[order(
  genome_gff$seqnames,                     # First, order by chromosome
  genome_gff$strand,                       # Then, order by strand
  ifelse(genome_gff$strand == "+",         # If strand is "+", order by start
         genome_gff$start, 
         -genome_gff$end)                  # If strand is "-", order by end in descending order
), ]

# View the first few rows of the ordered dataframe by strand
head(genome_gff[genome_gff$strand == "+",])
head(genome_gff[genome_gff$strand == "-",])
```


Now, we can filter to keep only genes that are not overlapping with each other. We first look for genes that overlap:

```{r}
# Initialize a vector to store overlap results
genome_gff$overlap <- FALSE

# Loop over genes, comparing each gene with the next one in the same strand
for (i in 1:(nrow(genome_gff) - 1)) {
  
  # Check if genes are on the same chromosome/scaffold and same strand
  if (genome_gff$seqnames[i] == genome_gff$seqnames[i + 1] &&
      genome_gff$strand[i] == genome_gff$strand[i + 1]){
    
    # Check overlap if strand is positive
    if (genome_gff$strand[i] == "+" &&
        genome_gff$end[i] >= genome_gff$start[i+1]) {
      genome_gff$overlap[i] <- TRUE
      genome_gff$overlap[i+1] <- TRUE
    }
   
     # Check overlap if strand is negative
    if (genome_gff$strand[i] == "-" &&
       genome_gff$start[i] <= genome_gff$end[i+1]) {
      genome_gff$overlap[i] <- TRUE
      genome_gff$overlap[i+1] <- TRUE
    }
  }
  
}

# Number of overlapping genes
nrow(genome_gff[genome_gff$overlap == TRUE,])
```


We remove the overlapping genes from `genome_gff` and check the number of remaining genes:

```{r gff_genome remove overlap genes}
# Remove overlapping genes from genome_gff
genome_gff <- genome_gff[!genome_gff$overlap, ]
nrow(genome_gff)
length(unique(genome_gff$ID))
```

### Chromosome lengths

To define the upstream regions the chromosome lengths are needed to be the maximum for the start of the upstream region of the genes on the negative strand.

Load chromosome lengths:

```{r load gbff}
gbff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gbff" 
file_lines <- readLines(gbff_file)
# Extract the LOCUS line
locus_lines <- file_lines[grep("^LOCUS", file_lines)]
head(locus_lines)
```

They don't seem to end with the dot and the number (version) as in the case of the `gff` data. Lets check if the `gff` has several versions:

```{r explore genome_gff versions}
length(unique(genome_gff$seqnames))
# Remove version suffix from seqnames
length(unique(sub("\\.\\d+$", "", genome_gff$seqnames)))
```

It does not have several versions, so we can remove the version numbers from `seqnames` in the `genome_gff` and from variable `dpp4_chr`.

```{r remove version from seqnames}
# Remove version numbers from seqnames in the filtered files
genome_gff$seqnames <- sub("\\.\\d+$", "", genome_gff$seqnames)
dpp4_chr <- "NC_036801"
```

```{r extract chrom names and lengths}
# Extract chromosome names and lengths
chrom_info <- gsub("^LOCUS\\s+(\\S+)\\s+(\\d+)\\s+.*$", "\\1,\\2", locus_lines)
rm(locus_lines)
chrom_info <- strsplit(chrom_info, ",")
chrom_names <- sapply(chrom_info, `[`, 1)
chrom_lengths <- as.numeric(sapply(chrom_info, `[`, 2))
# Create a named vector
chrom_lengths <- setNames(chrom_lengths, chrom_names)
```

```{r check correspondence genome_gff and chrom_lengths}
# Check how many chromosomes are in chrom_names but not in genome_gff$seqnames
length(setdiff(chrom_names, unique(genome_gff$seqnames)))

# You can also check the reverse - how many chromosomes in genome_gff$seqnames are not in chrom_names
length(setdiff(unique(genome_gff$seqnames), chrom_names))
```

### Define the 200 kb upstream genes of whole genome



```{r}
# Initialize the new columns for upstream start and end in genome_gff
genome_gff$upstream_start <- NA
genome_gff$upstream_end <- NA
genome_gff$upstream_length <- NA

# Process each chromosome separately
for (chr in unique(genome_gff$seqnames)) {
  chr_length <- chrom_lengths[chr]
  chr_genes <- genome_gff[genome_gff$seqnames == chr, ]
  
  ### Process positive strand genes ###
  
  pos_genes <- chr_genes[chr_genes$strand == "+", ]
  if (nrow(pos_genes) > 0) {
    
    # First gene in chromosome (positive strand)
    if (pos_genes$start[1] > 1){
      pos_genes$upstream_end[1] <- pos_genes$start[1] - 1
      pos_genes$upstream_start[1] <- max(1, pos_genes$start[1] - 20000)
      pos_genes$upstream_length[1] <- pos_genes$upstream_end[1] - pos_genes$upstream_start[1] + 1

      # Only keep upstream region if it's valid (at least 1 base)
      if (pos_genes$upstream_end[1] - pos_genes$upstream_start[1] < 0){
        pos_genes$upstream_start[1] <- NA
        pos_genes$upstream_end[1] <- NA
        pos_genes$upstream_length[1] <- NA
      }
    }
 
    # Remaining genes
    if (nrow(pos_genes) > 1) {
      for (i in 2:nrow(pos_genes)) {
        pos_genes$upstream_end[i] <- pos_genes$start[i] - 1
        pos_genes$upstream_start[i] <- max(pos_genes$start[i] - 20000, pos_genes$end[i-1] + 1)
        pos_genes$upstream_length[i] <- pos_genes$upstream_end[i] - pos_genes$upstream_start[i] + 1

        # Only keep upstream region if it's valid (at least 1 base)
        if (pos_genes$upstream_end[i] - pos_genes$upstream_start[i] < 0){
          pos_genes$upstream_start[i] <- NA
          pos_genes$upstream_end[i] <- NA
          pos_genes$upstream_length[i] <- NA
        }
      }
    }
  }
  
  ### Process negative strand genes ###
  neg_genes <- chr_genes[chr_genes$strand == "-", ]
  if (nrow(neg_genes) > 0) {
    
    # First gene in chromosome (negative strand)
    if (neg_genes$end[1] < chr_length) {
      neg_genes$upstream_start[1] <- min(chr_length, neg_genes$end[1] + 20000)
      neg_genes$upstream_end[1] <- neg_genes$end[1] + 1
      neg_genes$upstream_length[1] <- neg_genes$upstream_start[1] - neg_genes$upstream_end[1] + 1

      # Only keep upstream region if it's valid (at least 1 base)
      if (neg_genes$upstream_start[1] - neg_genes$upstream_end[1] < 0) {
        neg_genes$upstream_start[1] <- NA
        neg_genes$upstream_end[1] <- NA
        neg_genes$upstream_length[1] <- NA
      }
    }
    
    # Remaining genes
    if (nrow(neg_genes) > 1) {
      for (i in 2:nrow(neg_genes)) {
        neg_genes$upstream_start[i] <- min(neg_genes$end[i] + 20000, neg_genes$start[i-1] - 1)
        neg_genes$upstream_end[i] <- neg_genes$end[i] + 1
        neg_genes$upstream_length[i] <- neg_genes$upstream_start[i] - neg_genes$upstream_end[i] + 1

        # Only keep upstream region if it's valid (at least 1 base)
        if (neg_genes$upstream_start[i] - neg_genes$upstream_end[i] < 0) {
          neg_genes$upstream_start[i] <- NA
          neg_genes$upstream_end[i] <- NA
          neg_genes$upstream_length[i] <- NA
        }
      }
    }
  }
  
  # Update the main genome_gff dataframe
  if(nrow(pos_genes)>0){
    genome_gff[genome_gff$seqnames == chr & genome_gff$strand == "+", c("upstream_start", "upstream_end", "upstream_length")] <- 
    pos_genes[, c("upstream_start", "upstream_end", "upstream_length")]
  }
  
  if(nrow(neg_genes)>0){
    genome_gff[genome_gff$seqnames == chr & genome_gff$strand == "-", c("upstream_start", "upstream_end", "upstream_length")] <- 
    neg_genes[, c("upstream_start", "upstream_end", "upstream_length")]
  }
  
}

# Check the results
summary(genome_gff$upstream_length)
```


#### Subset chromosome of interest

```{r filter gff chromosome alternative}
chromosome_gff <- genome_gff[
  genome_gff$seqnames == dpp4_chr,
]
```

We can check the source of the filtered annotations:
```{r gff_chromosome table of annotation source}
table(chromosome_gff$source)
```

Check the number of remaining genes:

```{r gff_chromosome remaining genes}
nrow(chromosome_gff)
length(unique(chromosome_gff$ID))
```

Check the summary of the upstream lengths:

```{r}
summary(chromosome_gff$upstream_length)
```



#### Subset region of interest

```{r filter gff region alternative}
region_gff <- chromosome_gff[
  chromosome_gff$start <= region_end & 
  chromosome_gff$end >= region_start, 
]
```

We can check the source of the filtered annotations:
```{r gff_region table of annotation source}
table(region_gff$source)
```

Check the number of remaining genes:

```{r gff_region remaining genes}
nrow(region_gff)
length(unique(region_gff$ID))
```

We can visualize the genes on the region of interest:

```{r gff_region plot}
# Extract relevant columns
gene_data <- region_gff[, c("strand","start", "end", "gene")]

# Create a y-axis index for unique gene names
gene_data$y_index <- match(gene_data$gene, unique(gene_data$gene))

# Set gene colors based on strand information (red for negative strand, blue for positive strand)
gene_data$gene_color <- ifelse(gene_data$strand == "-", "red", "blue")

# Set up larger plotting area and adjust margins
par(mar=c(6, 10, 4, 2), xpd=TRUE)

# Create the plot with adjusted y-axis
plot(c(min(gene_data$start), max(gene_data$end)), 
     c(0, max(gene_data$y_index) + 1), 
     type="n", 
     xlab="Genomic Coordinates", 
     ylab="", 
     xaxt="n", 
     yaxt="n")

# Plot each gene as a line, with thicker line for GeneID:101483164
for (i in 1:nrow(gene_data)) {
  # Set line width for GeneID:101483164 (2x as thick)
  lwd_value <- ifelse(gene_data$gene[i] == "LOC101483164", 4, 1)
  
  # Plot the gene line with the appropriate color and line width
  segments(gene_data$start[i], gene_data$y_index[i], gene_data$end[i], gene_data$y_index[i], 
           col=gene_data$gene_color[i], lwd=lwd_value)
}

# Add gene names to the y-axis
axis(2, at=gene_data$y_index, labels=gene_data$gene, las=1, cex.axis=0.7)
# Add x-axis with genomic coordinates
axis(1)

# Optionally, add a grid for better visualization
grid()

# Add a legend at the top-left corner
legend("topright", 
       legend=c("Positive strand (blue)", "Negative strand (red)"), 
       fill=c("blue", "red"), 
       bty="n", cex=0.8)
```

Check the summary of the upstream lengths:

```{r summary of region upstream length}
summary(region_gff$upstream_length)
```



## Step 2: Filtering of CGI by promoter overlap

CGI annotation file (`.txt` file) obtained with makeCGI v1.3.4 [@hiddenMarkov]

```{r load cgi annotation file}
# Load the CGI annotation file
cgi_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/CGI-Mzebra.txt" 
cgif <- read.table(cgi_file, header = TRUE, sep = "\t")
head(cgif)
```
Lets remove the chromosome version number from the CGI annotation:

```{r}
cgif$chr <- sub("\\.\\d+$", "", cgif$chr)
```

Check the summary of the island lengths:

```{r summary of cgi lengths}
summary(cgif$length)
```

Not all chromosomes in `genome_gff` are in the CGI annotations:

```{r}
# Identify seqnames in genome_gff that are not in cgif
missing_seqnames <- setdiff(unique(genome_gff$seqnames), unique(cgif$chr))

# Print the missing seqnames
print(missing_seqnames)
```

To check when extracting chromosome info.
```{r}
nrow(cgif[cgif$chr==missing_seqnames[1],])
```

Lets visualize the islands in the genomic region of interest:

```{r, fig.height=4, fig.width=15}
# Set up plotting area with adjusted margins
par(mfrow = c(1,1))  
par(mar=c(5, 8, 4, 4))  # Increased right margin for legend

# Create y-coordinates for each type
y_coords <- c(1, 2, 3)  # 1 for neg strand, 2 for pos strand, 3 for CGIs

# Get the x-axis range including both genes and CGIs
x_range <- range(c(region_gff$start, region_gff$end))

# Create the empty plot
plot(x_range, c(0.5, 3.5), 
     type="n", 
     xlab="Genomic Coordinates",
     ylab="",
     yaxt="n",  # Remove y-axis ticks
     main="Genes and CpG Islands")

# Add custom y-axis labels
axis(2, at=y_coords, 
     labels=c("- Strand Genes", "+ Strand Genes", "Islands"),
     las=1)  # Horizontal labels

# Plot genes on negative strand
neg_genes <- region_gff[region_gff$strand == "-", ]
for(i in 1:nrow(neg_genes)) {
    segments(neg_genes$start[i], y_coords[1], 
            neg_genes$end[i], y_coords[1],
            col="red", lwd=2)
}

# Plot genes on positive strand
pos_genes <- region_gff[region_gff$strand == "+", ]
for(i in 1:nrow(pos_genes)) {
    segments(pos_genes$start[i], y_coords[2], 
            pos_genes$end[i], y_coords[2],
            col="blue", lwd=2)
}

# Plot CGIs
region_cgis <- cgif[cgif$chr == dpp4_chr & 
                   cgif$start >= region_start & 
                   cgif$end <= region_end,]

for(i in 1:nrow(region_cgis)) {
    segments(region_cgis$start[i], y_coords[3], 
            region_cgis$end[i], y_coords[3],
            col="darkgreen", lwd=2)
}

# Add grid
grid(col="gray90")

```

For each position within each upstream region we check whether it is in a CGI and the distance to the gene.


```{r, eval = FALSE}
# Function to efficiently check if positions are within any CGI
is_within_cgi_vector <- function(positions, cgi_intervals) {
  # Apply the check for each position against all intervals
  sapply(positions, function(pos) {
    any(pos >= cgi_intervals[,1] & pos <= cgi_intervals[,2])
  })
}

# Initialize result dataframe
cgiVsDistance <- matrix(data = NA, nrow = nrow(genome_gff), ncol = 20000)

# Get the genome_gff indices for genes with a defined upstream region
nonNA_upstream <- which(!is.na(genome_gff$upstream_length))


# Set start variable for previous chromosome name
prev_chrom_name <- 0

for (i in nonNA_upstream){
  # Get current chromosome name
  chrom_name <- genome_gff$seqnames[i]
  # Get the cgi annotations for the current chromosome
  if (prev_chrom_name != chrom_name){
    chrom_cgi <- cgif[cgif$chr==chrom_name,]
    # Create a matrix of CGI intervals for faster lookup
    chrom_cgi_intervals <- cbind(chrom_cgi$start, chrom_cgi$end)
  }
  
  # Get the sequence of upstream positions
  upstream_start <- genome_gff$upstream_start[i]
  upstream_end <- genome_gff$upstream_end[i]
  if (upstream_start > upstream_end) { # Upstream in the negative strand
    positions <- seq(from = upstream_end, to = upstream_start, by = 1)
  } else { # Upstream in the positive strand
    positions <- seq(from = upstream_start, to = upstream_end, by = 1)
  }
  
  # Get CGI status for all positions at once
  in_cgi <- is_within_cgi_vector(positions, chrom_cgi_intervals)
  
  # Get the sequence of upstream distances to the gene start
  if(genome_gff$strand[i] == "+") {
    # For positive strand: distance from gene start
    distances <- genome_gff$start[i] - positions
  } else {
    # For negative strand: distance from gene end
    distances <- positions - genome_gff$end[i]
  }
  
  # Save the CGI status in the distance matrix
  cgiVsDistance[i,distances] <- in_cgi
  
  # Update the variable for the previous chromosome name
  prev_chrom_name <- chrom_name
}
```

```{r, eval=FALSE}
save(cgiVsDistance, file = "cgiVsDistance.RData")
```

```{r}
load("cgiVsDistance.RData")
```

Now we can calculate the probability of each promoter site (described by the distance to the gene) to be in a CGI:

```{r}
cgiProbByDistance <- colMeans(cgiVsDistance, na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance))
```




```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```

#### Subset chromosome of interest

```{r}
cgiProbByDistance <- colMeans(cgiVsDistance[which(genome_gff$seqnames == dpp4_chr),], na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance[which(genome_gff$seqnames == dpp4_chr),]))
```

```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```

#### Subset region of interest

```{r}
region_indeces <- genome_gff$seqnames == dpp4_chr & genome_gff$start <= region_end & genome_gff$end >= region_start
cgiProbByDistance <- colMeans(cgiVsDistance[region_indeces,], na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance[region_indeces,]))
```


```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```


## Step 3: Island assignation to closer gene

Neglecting those islands that intersect gene bodies, we get the overlaps of CGI with upstream regions:

```{r}
library(GenomicRanges)

### Step 1: Filter CGI not within gene bodies ###

# Create GRanges for two sets with different chromosomes
gr_cgi <- GRanges(seqnames = cgif$chr,
                  ranges = IRanges(start = cgif$start,
                                   end = cgif$end))

gr_genes <- GRanges(seqnames = genome_gff$seqnames,
                    ranges = IRanges(start = genome_gff$start,
                                     end = genome_gff$end))

# Subset common chromosomes (seqnames)
common_seqnames <- intersect(seqlevels(gr_cgi), seqlevels(gr_genes))
gr_cgi <- keepSeqlevels(gr_cgi, common_seqnames, pruning.mode = "coarse")
gr_genes <- keepSeqlevels(gr_genes, common_seqnames, pruning.mode = "coarse")

# Find overlaps
overlap_result <- overlapsAny(gr_cgi, gr_genes)

# Subset non-overlapping CG islands
non_overlapping_cgi <- gr_cgi[!overlap_result]

### Step 2: Find overlaps of CGI with upstream regions ###

# Filter out rows with NA in upstream_start or upstream_end 
genome_gff_clean <- genome_gff[!is.na(genome_gff$upstream_start) & !is.na(genome_gff$upstream_end), ]

# Rename upstream_start and upstream_end from the "-" strand as in GRanges objects
# each range must have an end that is greater or equal to its start minus one
inverted_start <- genome_gff_clean$upstream_end[genome_gff_clean$strand == "-"]
inverted_end <- genome_gff_clean$upstream_start[genome_gff_clean$strand == "-"]
genome_gff_clean$upstream_start[genome_gff_clean$strand == "-"] <- inverted_start
genome_gff_clean$upstream_end[genome_gff_clean$strand == "-"] <- inverted_end

# Create a GRanges object for upstream regions
upstream_regions <- GRanges(
  seqnames = genome_gff_clean$seqnames,
  ranges = IRanges(start = genome_gff_clean$upstream_start, end = genome_gff_clean$upstream_end),
  gene_id = genome_gff_clean$ID,
  strand = genome_gff_clean$strand
)

# Subset common chromosomes (seqnames)
common_seqnames <- intersect(seqlevels(non_overlapping_cgi), seqlevels(upstream_regions))
non_overlapping_cgi <- keepSeqlevels(non_overlapping_cgi, common_seqnames, pruning.mode = "coarse")
upstream_regions <- keepSeqlevels(upstream_regions, common_seqnames, pruning.mode = "coarse")

# Find overlaps between non-overlapping CG islands and upstream regions
upstream_overlap <- findOverlaps(non_overlapping_cgi, upstream_regions)

### Step 3: Extract details of overlaps ###

# Query (CGI) and subject (upstream regions) indices
cgi_indices <- queryHits(upstream_overlap)
upstream_indices <- subjectHits(upstream_overlap)

# Calculate the number of overlaps for each CGI
cgi_overlap_counts <- table(cgi_indices) # Creates a named vector with CGI indices as names and counts as values

# Create a vector that maps the overlap count to each CGI in overlap_info
overlap_number <- cgi_overlap_counts[as.character(cgi_indices)] # Map counts back to the corresponding CGI index

# Map upstream regions back to the original genome_gff_clean to get gene start and end
gene_start <- genome_gff_clean$start[match(mcols(upstream_regions)$gene_id[upstream_indices], genome_gff_clean$ID)]
gene_end <- genome_gff_clean$end[match(mcols(upstream_regions)$gene_id[upstream_indices], genome_gff_clean$ID)]


# Combine relevant information
overlap_info <- data.frame(
  CGI_Chr = seqnames(non_overlapping_cgi)[cgi_indices],
  CGI_Start = start(non_overlapping_cgi)[cgi_indices],
  CGI_End = end(non_overlapping_cgi)[cgi_indices],
  Gene_ID = mcols(upstream_regions)$gene_id[upstream_indices],
  Gene_Start = gene_start,
  Gene_End = gene_end,
  Upstream_Start = start(upstream_regions)[upstream_indices],
  Upstream_End = end(upstream_regions)[upstream_indices],
  Upstream_Length = width(upstream_regions)[upstream_indices],
  Strand = as.character(strand(upstream_regions)[upstream_indices]),
  Overlap_Number = as.integer(overlap_number)
)

# Calculate the distance to the gene based on the strand
distance_to_gene <- ifelse(
  overlap_info$Strand == "+",
  overlap_info$Gene_Start - overlap_info$CGI_End, # Positive strand: distance from CGI_End to Gene_Start
  overlap_info$CGI_Start - overlap_info$Gene_End # Negative strand: distance from CGI_Start to Gene_End
)

# Add the distance_to_gene column to overlap_info
overlap_info$Distance_to_Gene <- distance_to_gene

# Inspect the result
head(overlap_info)

```

Number of upstream regions each island intersects with:

```{r}
table(overlap_info$Overlap_Number)
```

Summary of distances from the islands to the associated gene:

```{r}
summary(overlap_info$Distance_to_Gene)
```


```{r}
# Count the number of CGIs assigned to each gene
gene_cgi_counts <- table(overlap_info$Gene_ID)

# Create a frequency table of these counts
count_distribution <- table(gene_cgi_counts)

# Plot
barplot(
  height = as.numeric(count_distribution), # y-axis: number of genes
  names.arg = names(count_distribution),   # x-axis: CGI counts per gene
  xlab = "Number of CGIs assigned to a gene", 
  ylab = "Number of genes",
  main = "Distribution of CGI Assignments to Genes",
  col = "skyblue",
  border = "black"
)
```

Now from those islands that were associated to 2 upstream regions (positive and negative strand), we keep only the entry corresponding to the closer gene:

```{r}
# Step 1: Split overlap_info by unique CGI coordinates
cgi_groups <- split(overlap_info, paste(overlap_info$CGI_Chr, overlap_info$CGI_Start, overlap_info$CGI_End))

# Step 2: For each group, keep the row with the smallest Distance_to_Gene
filtered_overlap_info <- do.call(rbind, lapply(cgi_groups, function(group) {
  group[which.min(group$Distance_to_Gene), ] # Select the row with the minimum Distance_to_Gene
}))

# Step 3: Reset row names
rownames(filtered_overlap_info) <- NULL

# Step 4: Inspect the filtered result
head(filtered_overlap_info)

```

```{r}
# Check that the number of entries filtered out corresponds to half of the original number of entries corresponding to islands assigned to 2 genes
nrow(overlap_info) - nrow(filtered_overlap_info) == table(overlap_info$Overlap_Number)[2]/2
```

```{r}
# Count the number of CGIs assigned to each gene
gene_cgi_counts <- table(filtered_overlap_info$Gene_ID)

# Create a frequency table of these counts
count_distribution <- table(gene_cgi_counts)

# Plot
barplot(
  height = as.numeric(count_distribution), # y-axis: number of genes
  names.arg = names(count_distribution),   # x-axis: CGI counts per gene
  xlab = "Number of CGIs assigned to a gene", 
  ylab = "Number of genes",
  main = "Distribution of CGI Assignments to Genes",
  col = "skyblue",
  border = "black"
)
```


**Maybe I should check the order of the filtering, as all those genes overlapping with each other were removed from genome_gff before, so maybe some of the islands that are kept here because they dont overlap gene bodies actually would overlap with those genes that were removed**

*Not now at least, but keep it in mind when looking at the results*


# References