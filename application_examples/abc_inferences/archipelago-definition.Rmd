---
title: "Definition of Archipelagos"
author: "Sara"
date: "`r Sys.Date()`"
output: html_document
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning=FALSE, message=FALSE}
# If missing, install required packages

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("rtracklayer", quietly = TRUE)) {
  BiocManager::install("rtracklayer")
}

if (!requireNamespace("GenomicRanges", quietly = TRUE)) {
  BiocManager::install("GenomicRanges")
}



library(GenomicRanges)
library(rtracklayer)
```


# Archipelago definition

We define archipelagos as genomic regions containing clusters of CGIs. We can interpret archipelagos as regions of the genome larger than CGI that together may regulate a gene or set of genes. Therefore, an approach to define archipelagos can be to choose thresholds that lead to clustering CGI in a way so that each archipelago overlaps with a promoter region (or maximizes cases of overlap single-archipelago and promoter).

Our approach then has the following steps:

1. Definition of promoter regions.
2. Filtering of CGI by promoter overlap.


## Step 1: Definition of promoter regions

As in [@vernaz2022epigenetic], since no functional annotation exists for Lake Malawi cichlid genomes, we define promoter regions in silico as regions Â±1 kbp around the TSS.

For that, we use [Annotation Features File (GTF) from the NCBI RefSeq Assembly](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000238955.4/)

```{r}
# Load the GTF file
gtf_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gtf" 
gtf <- import(gtf_file)
head(gtf)
```

The gtf file is structured as a GRanges object containing genomic annotation information with the following key components (columns):

- `seqnames`: Chromosome or scaffold name (e.g., NC_036780.1).

- `ranges`: Start and end positions of the genomic feature.

- `strand`: Strand of the feature (+ for forward strand, - for reverse strand).

- `source`: Annotation source (e.g., Gnomon).

- `type`: Feature type (e.g., gene, transcript, exon).

- `Metadata`: Additional columns include gene_id, transcript_id, gene, product, gene_biotype, exon_number, etc., which describe the feature in detail.

Example Entries:

- Row 1: A gene on the + strand, identified as LOC106676409, classified as lncRNA.

- Row 2: A transcript corresponding to the same gene.

- Rows 3-5: Exons belonging to the transcript.

- Row 6: A gene on the - strand, classified as protein_coding.

We filter for transcripts:

```{r}
# Filter for transcripts
gtf_transcripts <- gtf[gtf$type == "transcript", ]
head(gtf_transcripts)
```

And define the TSS by accounting for the strand orientation so that:

- For Features on the + Strand: The TSS is the smallest genomic coordinate (start).

- For Features on the - Strand: The TSS is the largest genomic coordinate (end), as transcription occurs in the reverse direction.

```{r}
# Extract TSS
tss <- data.frame(
  chr = seqnames(gtf_transcripts),
  tss = ifelse(strand(gtf_transcripts) == "+", start(gtf_transcripts), end(gtf_transcripts)),
  strand = strand(gtf_transcripts)
)
head(tss)
```

The tss data frame contains:

- `chr`: Chromosome names

- `tss`: Transcription start sites

- `strand`: Strand orientation of the transcripts

## Step 2: Filtering of CGI by promoter overlap

CGI annotation file (`.txt` file) obtained with makeCGI v1.3.4 [@hiddenMarkov]

```{r}
# Load the CGI annotation file
cgi_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/CGI-Mzebra.txt" 
cgif <- read.table(cgi_file, header = TRUE, sep = "\t")
head(cgif)
```

Convert the promoter and CGI data to `GRanges` objects for genomic interval operations:

```{r}
# Create GRanges for promoters
promoter_gr <- GRanges(
  seqnames = promoters$chr,
  ranges = IRanges(start = promoters$tss, end = promoters$tss),
  strand = promoters$strand
)

# Create GRanges for CGI
cgi_gr <- GRanges(
  seqnames = cgif$chr,
  ranges = IRanges(start = cgif$start, end = cgif$end)
)
```

Use `findOverlaps` to find promoters within or near CpG islands:

```{r}
# Find overlaps
overlaps <- findOverlaps(promoter_gr, cgi_gr)

# Extract overlapping promoter indices
promoters_with_cgi <- promoters[queryHits(overlaps), ]
cgi_overlaps <- cgif[subjectHits(overlaps), ]

# Combine data for output
promoter_cgi_overlap <- cbind(promoters_with_cgi, cgi_overlaps)
head(promoter_cgi_overlap)
```

The `promoter_cgi_overlap` dataset combines information about promoters and CpG islands (CGIs) where they overlap. It contains the following columns:

- `chr`: The chromosome where the promoter is located.
    
- `tss`: The transcription start site (TSS) position of the promoter.

- `strand`: The strand of the promoter (+ or -).

- `chr`: The chromosome where the CGI is located (same as the promoter in the overlap context).

- `start`: The start position of the overlapping CGI.

- `end`: The end position of the overlapping CGI.

- `length`: The length of the CGI in base pairs.

- `CpGcount`: The number of CpG dinucleotides within the CGI.

- `GCcount`: The number of G and C nucleotides within the CGI.

- `pctGC`: The percentage of G and C nucleotides within the CGI.

- `obsExp`: The observed-to-expected ratio of CpG dinucleotides in the CGI.

Each row corresponds to an overlap between a promoter and a CGI. For example:

- The first row shows that a promoter at TSS 755,445 on the negative strand overlaps with a CGI on chromosome NC_036780.1 spanning positions 755,397 to 756,689. This CGI has a length of 1,293 bp, contains 123 CpG dinucleotides, and has a GC content of 63.19% with an observed-to-expected CpG ratio of 0.954.

- The overlap is detailed for both the promoter and the CGI, including their respective properties.

```{r}
#write.table(promoter_cgi_overlap, file = "promoter_cgi_overlap.txt", sep = "\t", row.names = FALSE)
promoter_cgi_overlap <- read.table("/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/promoter_cgi_overlap.txt")
```

### Check TSS overlap density

```{r}
plot(
  promoter_cgi_overlap$length, 
  promoter_cgi_overlap$pctGC, 
  xlab = "CGI Length (bp)", 
  ylab = "GC Content (%)", 
  main = "Relationship Between CGI Length and GC Content",
  pch = 16,  # Solid circle points
  col = "blue"  # Point color
)

```


# Dirk idea

## Explore the data

```{r}
unique(gtf$type)
```

The gtf contains: gene, transcript, exon, CDS, start_codon and stop_codon

Lets filter the genes:

```{r}
genes <- gtf[gtf$type == "gene",]
dim(as.data.frame(genes))
```

Are the genes duplicated?

```{r}
length(genes$gene_id)
length(unique(genes$gene_id))
```


Lets explore the annotation sources:

```{r}
unique(genes$source)
```

Summary table:

| Source        | Primary Focus                       | Reliability          | Features                                         |
|---------------|-------------------------------------|----------------------|--------------------------------------------------|
| Gnomon        | Computational gene prediction       | Medium               | Predicted genes, transcripts, and exons         |
| cmsearch      | RNA homology                        | Medium-High          | Non-coding RNAs (e.g., ribosomal RNAs)          |
| tRNAscan-SE   | tRNA genes                          | High                 | tRNA annotations                                 |
| BestRefSeq    | High-confidence curated annotations | High                 | Protein-coding and non-coding genes             |
| BestRefSeq, Gnomon | Combined curated and predicted annotations | Medium-High | Hybrid of RefSeq and Gnomon predictions         |
| RefSeq        | Broader RefSeq annotations          | Mixed (High to Low)  | Protein-coding and non-coding genes             |



## Define the 200 kb upstream regions

First, save chromosome lengths:

```{r}
gbff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gbff" 
file_lines <- readLines(gbff_file)
# Extract the LOCUS line
locus_lines <- file_lines[grep("^LOCUS", file_lines)]
head(locus_lines)
```

They dont seem to end with the dot and the number (version) as in the case of the `gtf_genes` data. Lets check if the `gtf_genes` (or the dataframe obtained from it) has several versions:

```{r}
length(unique(genes_df$seqnames))
# Remove version suffix from seqnames
length(unique(sub("\\.\\d+$", "", genes_df$seqnames)))
```

It does not have several versions.

```{r}
# Extract chromosome names and lengths
chrom_info <- gsub("^LOCUS\\s+(\\S+)\\s+(\\d+)\\s+.*$", "\\1,\\2", locus_lines)
chrom_info <- strsplit(chrom_info, ",")
chrom_names <- sapply(chrom_info, `[`, 1)
chrom_lengths <- as.numeric(sapply(chrom_info, `[`, 2))
# Create a named vector
chrom_lengths <- setNames(chrom_lengths, chrom_names)

# Remove version numbers from seqnames in genes_df
genes_df$seqnames <- sub("\\.\\d+$", "", genes_df$seqnames)

```



Calculate the upstream start and end to prevent overlap with the previous gene.

```{r}
# Ensure genes_df is sorted by seqnames and start position
genes_df <- genes_df[order(genes_df$seqnames, genes_df$start), ]

# Initialize the upstream_start column
genes_df$upstream_start <- NA

# Iterate over genes to adjust upstream_start
for (i in 1:nrow(genes_df)) {
  current_gene <- genes_df[i, ]
  current_chrom <- current_gene$seqnames
  current_strand <- current_gene$strand
  current_start <- current_gene$start
  current_end <- current_gene$end

  # Find the previous gene on the same chromosome
  previous_gene <- genes_df[i - 1, ]
  if (i > 1 && previous_gene$seqnames == current_chrom) {
    previous_end <- previous_gene$end
    previous_start <- previous_gene$start
  } else {
    previous_end <- NA
    previous_start <- NA
  }

  # Adjust upstream_start based on strand and previous gene position
  if (current_strand == "+") {
    if (!is.na(previous_end)) {
      genes_df$upstream_start[i] <- max(current_start - 200000, previous_end)
    } else {
      genes_df$upstream_start[i] <- max(current_start - 200000, 1)
    }
  } else if (current_strand == "-") {
    if (!is.na(previous_start)) {
      genes_df$upstream_start[i] <- min(current_end + 200000, previous_start)
    } else {
      genes_df$upstream_start[i] <- min(current_end + 200000, chrom_lengths[current_chrom])
    }
  }
}

```

Filter for "curated" chromosomes:

```{r}
# Filter genes_df to keep only those rows where seqnames starts with "NC"
genes_df_filtered <- genes_df[grep("^NC", genes_df$seqnames), ]

# Check the result
head(genes_df_filtered)

```

Still it seems there is nothing but genes. Maybe I should have filtered for something else.

In a GTF (Gene Transfer Format) file, the gene feature type represents the entire gene, including all its exons, introns, and regulatory regions. The transcript feature type corresponds to a specific transcript variant of the gene, encompassing all exons and introns of that transcript. The exon feature type denotes individual exonic regions within a transcript. The CDS (Coding Sequence) feature type indicates the portion of the gene or transcript that codes for protein. The start_codon and stop_codon feature types mark the beginning and end of the coding sequence, respectively. 
**Try gff**

```{r}
gtf_df[gtf_df$seqnames=="NC_036801.1" & gtf_df$type == "gene",]
gtf_df[gtf_df$gene_id == "LOC101483164",]
```

```{r}
dpp4_chr <- "NC_036801.1"
dpp4_start <- 29502362
dpp4_end <- 29517382
gtf_df[gtf_df$seqnames=="NC_036801.1" & gtf_df$type == "gene" & gtf_df$start > dpp4_start - 5e5 & gtf_df$end > dpp4_end + 5e5  ,]
```








