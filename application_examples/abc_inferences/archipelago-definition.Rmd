---
title: "Definition of Archipelagos"
author: "Sara"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries, warning=FALSE, message=FALSE, echo=FALSE}
# If missing, install required packages

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("rtracklayer", quietly = TRUE)) {
  BiocManager::install("rtracklayer")
}

library(rtracklayer)
```

# Archipelago definition

We define archipelagos as genomic regions containing clusters of CGIs. We can interpret archipelagos as regions of the genome larger than CGI that together may regulate a gene or set of genes. Therefore, an approach to define archipelagos can be to choose thresholds that lead to clustering CGI in a way so that each archipelago overlaps with a promoter region (or maximizes cases of overlap single-archipelago and promoter).

Our approach then has the following steps:

1. Definition of promoter regions.
2. Filtering of CGI by promoter overlap.

We will perform this steps for the genomic region of interest:

```{r set region values}
dpp4_chr <- "NC_036801.1"
dpp4_start <- 29502362
dpp4_end <- 29517382
region_start <- dpp4_start - 5e5
region_end <- dpp4_end + 5e5
```

- DPP4 gene location:

  - Chromosome: NC_036801.1
  
      - Start: 29,502,362
      
      - End: 29,517,382
        
- Extended Region: Includes 500,000 base pairs upstream and downstream of the DPP4 gene.


## Step 1: Definition of "promoter/upstream" regions

As in [@vernaz2022epigenetic], since no functional annotation exists for Lake Malawi cichlid genomes, we define promoter regions in silico as regions Â±1 kbp around the TSS.


### Choice of gene annotiation file format

File formats from [NCBI](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000238955.4/). Selected RefSeq only (no Ensembl annotation). More info [here](https://www.biobam.com/differences-between-gtf-and-gff-files-in-genomic-data-analysis/), [here](http://www.ensembl.org/info/website/upload/gff.html) and [here](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-020-6707-9). 


- The General Feature Format (GFF): GFF is a standard file format used for storing genomic sequences and annotations, developed by the Sanger Centre (v2) and the Sequence Ontology Project (v3). It describes features and annotations of DNA, RNA, and protein sequences in a plain text format with nine fields separated by tabs. Focuses on the hierarchical structure of genome annotations and is often less verbose.

- The Gene Transfer Format (GTF): GTF, often seen as a derivative of GFF, is more specific in its application. It was generally termed GTF around 2000 and developed as part of collaborative genome annotation projects. GTF borrows from GFF but has additional structures for detailed gene annotations, often used to describe transcripts and their coding sequences.

The `.gtf` file contains more information, but for our purpose we can use the `.gff` file.

```{r load gff}
# Load the GFF file
gff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gff" 
gff <- as.data.frame(import(gff_file))
names(gff)
```

- `seqnames`: Chromosome.

- `start`, `end`: Coordinates of the gene.

- `strand`: Gene orientation.

- `type`: Feature type (here filtered for genes).

- `Gene`: Gene name or ID.

- `gene_biotype`: Functionality (e.g., protein_coding)

Lets keep the relevant columns:

```{r gff filter relevant columns}
gff <- gff[,c("seqnames", "start", "end", "width", "strand", "type", "source", "ID", "Dbxref", "gene")]
```


```{r gff table of annotation type}
table(gff$type)
```

```{r gff table of annotation source}
table(gff$source)
```

- `source`: indicates the source of the annotation for each feature in the file. These sources represent the tools, pipelines, or databases that generated the corresponding annotation.

  - `RefSeq`: These annotations come directly from the RefSeq database. RefSeq annotations are high-quality, manually curated or computationally derived features that are part of NCBI's Reference Sequence project. Examples: Protein-coding genes, RNA genes, pseudogenes.

   - `Gnomon`: Gnomon is NCBI's gene prediction tool, which generates computationally predicted annotations. These annotations may include protein-coding genes, non-coding RNAs, or other features predicted based on sequence analysis. Gnomon is used when there is no manually curated annotation available for certain regions or genes.

   - `cmsearch`: This refers to the Infernal package (specifically the cmsearch tool), which identifies RNA features such as non-coding RNAs or structured RNA elements.  Often used for annotating RNA families based on covariance models.

  - `tRNAscan-SE`: tRNAscan-SE is a specialized tool for identifying and annotating tRNA genes in genome sequences. Annotations with this source indicate regions identified as tRNAs through this tool.

   - `BestRefSeq`: Features with this source are part of the BestRefSeq annotation, which integrates high-quality manual curation with computational predictions to produce a "best" annotation for a gene or transcript. BestRefSeq annotations are typically the most reliable.

  - BestRefSeq,Gnomon (or `BestRefSeq%2CGnomon`): This indicates that a feature is annotated by both the BestRefSeq and Gnomon pipelines. Such annotations may combine curated data with computational predictions.

### Filter genes of whole genome

First, we filter the GFF file to keep only genes.
```{r filter gff genome}
genome_gff <- gff[
  gff$type == "gene", 
]
```

We can check the source of the filtered annotations:
```{r gff_genome table of annotation source}
table(genome_gff$source)
```

And the number of genes:

```{r gff_genome number of genes}
nrow(genome_gff)
length(unique(genome_gff$ID))
```

We order the entries:

```{r order genome_gff}
genome_gff <- genome_gff[order(
  genome_gff$seqnames,                     # First, order by chromosome
  genome_gff$strand,                       # Then, order by strand
  ifelse(genome_gff$strand == "+",         # If strand is "+", order by start
         genome_gff$start, 
         -genome_gff$end)                  # If strand is "-", order by end in descending order
), ]

# View the first few rows of the ordered dataframe by strand
head(genome_gff[genome_gff$strand == "+",])
head(genome_gff[genome_gff$strand == "-",])
```


Now, we can filter to keep only genes that are not overlapping with each other. We first look for genes that overlap:

```{r}
# Initialize a vector to store overlap results
genome_gff$overlap <- FALSE

# Loop over genes, comparing each gene with the next one in the same strand
for (i in 1:(nrow(genome_gff) - 1)) {
  
  # Check if genes are on the same chromosome/scaffold and same strand
  if (genome_gff$seqnames[i] == genome_gff$seqnames[i + 1] &&
      genome_gff$strand[i] == genome_gff$strand[i + 1]){
    
    # Check overlap if strand is positive
    if (genome_gff$strand[i] == "+" &&
        genome_gff$end[i] >= genome_gff$start[i+1]) {
      genome_gff$overlap[i] <- TRUE
      genome_gff$overlap[i+1] <- TRUE
    }
   
     # Check overlap if strand is negative
    if (genome_gff$strand[i] == "-" &&
       genome_gff$start[i] <= genome_gff$end[i+1]) {
      genome_gff$overlap[i] <- TRUE
      genome_gff$overlap[i+1] <- TRUE
    }
  }
  
}

# Number of overlapping genes
nrow(genome_gff[genome_gff$overlap == TRUE,])
```


We remove the overlapping genes from `genome_gff` and check the number of remaining genes:

```{r gff_genome remove overlap genes}
# Remove overlapping genes from genome_gff
genome_gff <- genome_gff[!genome_gff$overlap, ]
nrow(genome_gff)
length(unique(genome_gff$ID))
```

### Chromosome lengths

To define the upstream regions the chromosome lengths are needed to be the maximum for the start of the upstream region of the genes on the negative strand.

Load chromosome lengths:

```{r load gbff}
gbff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gbff" 
file_lines <- readLines(gbff_file)
# Extract the LOCUS line
locus_lines <- file_lines[grep("^LOCUS", file_lines)]
head(locus_lines)
```

They don't seem to end with the dot and the number (version) as in the case of the `gff` data. Lets check if the `gff` has several versions:

```{r explore genome_gff versions}
length(unique(genome_gff$seqnames))
# Remove version suffix from seqnames
length(unique(sub("\\.\\d+$", "", genome_gff$seqnames)))
```

It does not have several versions, so we can remove the version numbers from `seqnames` in the `genome_gff` and from variable `dpp4_chr`.

```{r remove version from seqnames}
# Remove version numbers from seqnames in the filtered files
genome_gff$seqnames <- sub("\\.\\d+$", "", genome_gff$seqnames)
dpp4_chr <- "NC_036801"
```

```{r extract chrom names and lengths}
# Extract chromosome names and lengths
chrom_info <- gsub("^LOCUS\\s+(\\S+)\\s+(\\d+)\\s+.*$", "\\1,\\2", locus_lines)
rm(locus_lines)
chrom_info <- strsplit(chrom_info, ",")
chrom_names <- sapply(chrom_info, `[`, 1)
chrom_lengths <- as.numeric(sapply(chrom_info, `[`, 2))
# Create a named vector
chrom_lengths <- setNames(chrom_lengths, chrom_names)
```

```{r check correspondence genome_gff and chrom_lengths}
# Check how many chromosomes are in chrom_names but not in genome_gff$seqnames
length(setdiff(chrom_names, unique(genome_gff$seqnames)))

# You can also check the reverse - how many chromosomes in genome_gff$seqnames are not in chrom_names
length(setdiff(unique(genome_gff$seqnames), chrom_names))
```

### Define the 200 kb upstream genes of whole genome



```{r}
# Initialize the new columns for upstream start and end in genome_gff
genome_gff$upstream_start <- NA
genome_gff$upstream_end <- NA
genome_gff$upstream_length <- NA

# Process each chromosome separately
for (chr in unique(genome_gff$seqnames)) {
  chr_length <- chrom_lengths[chr]
  chr_genes <- genome_gff[genome_gff$seqnames == chr, ]
  
  ### Process positive strand genes ###
  
  pos_genes <- chr_genes[chr_genes$strand == "+", ]
  if (nrow(pos_genes) > 0) {
    
    # First gene in chromosome (positive strand)
    if (pos_genes$start[1] > 1){
      pos_genes$upstream_end[1] <- pos_genes$start[1] - 1
      pos_genes$upstream_start[1] <- max(1, pos_genes$start[1] - 20000)
      pos_genes$upstream_length[1] <- pos_genes$upstream_end[1] - pos_genes$upstream_start[1] + 1

      # Only keep upstream region if it's valid (at least 1 base)
      if (pos_genes$upstream_end[1] - pos_genes$upstream_start[1] < 0){
        pos_genes$upstream_start[1] <- NA
        pos_genes$upstream_end[1] <- NA
        pos_genes$upstream_length[1] <- NA
      }
    }
 
    # Remaining genes
    if (nrow(pos_genes) > 1) {
      for (i in 2:nrow(pos_genes)) {
        pos_genes$upstream_end[i] <- pos_genes$start[i] - 1
        pos_genes$upstream_start[i] <- max(pos_genes$start[i] - 20000, pos_genes$end[i-1] + 1)
        pos_genes$upstream_length[i] <- pos_genes$upstream_end[i] - pos_genes$upstream_start[i] + 1

        # Only keep upstream region if it's valid (at least 1 base)
        if (pos_genes$upstream_end[i] - pos_genes$upstream_start[i] < 0){
          pos_genes$upstream_start[i] <- NA
          pos_genes$upstream_end[i] <- NA
          pos_genes$upstream_length[i] <- NA
        }
      }
    }
  }
  
  ### Process negative strand genes ###
  neg_genes <- chr_genes[chr_genes$strand == "-", ]
  if (nrow(neg_genes) > 0) {
    
    # First gene in chromosome (negative strand)
    if (neg_genes$end[1] < chr_length) {
      neg_genes$upstream_start[1] <- min(chr_length, neg_genes$end[1] + 20000)
      neg_genes$upstream_end[1] <- neg_genes$end[1] + 1
      neg_genes$upstream_length[1] <- neg_genes$upstream_start[1] - neg_genes$upstream_end[1] + 1

      # Only keep upstream region if it's valid (at least 1 base)
      if (neg_genes$upstream_start[1] - neg_genes$upstream_end[1] < 0) {
        neg_genes$upstream_start[1] <- NA
        neg_genes$upstream_end[1] <- NA
        neg_genes$upstream_length[1] <- NA
      }
    }
    
    # Remaining genes
    if (nrow(neg_genes) > 1) {
      for (i in 2:nrow(neg_genes)) {
        neg_genes$upstream_start[i] <- min(neg_genes$end[i] + 20000, neg_genes$start[i-1] - 1)
        neg_genes$upstream_end[i] <- neg_genes$end[i] + 1
        neg_genes$upstream_length[i] <- neg_genes$upstream_start[i] - neg_genes$upstream_end[i] + 1

        # Only keep upstream region if it's valid (at least 1 base)
        if (neg_genes$upstream_start[i] - neg_genes$upstream_end[i] < 0) {
          neg_genes$upstream_start[i] <- NA
          neg_genes$upstream_end[i] <- NA
          neg_genes$upstream_length[i] <- NA
        }
      }
    }
  }
  
  # Update the main genome_gff dataframe
  if(nrow(pos_genes)>0){
    genome_gff[genome_gff$seqnames == chr & genome_gff$strand == "+", c("upstream_start", "upstream_end", "upstream_length")] <- 
    pos_genes[, c("upstream_start", "upstream_end", "upstream_length")]
  }
  
  if(nrow(neg_genes)>0){
    genome_gff[genome_gff$seqnames == chr & genome_gff$strand == "-", c("upstream_start", "upstream_end", "upstream_length")] <- 
    neg_genes[, c("upstream_start", "upstream_end", "upstream_length")]
  }
  
}

# Check the results
summary(genome_gff$upstream_length)
```


#### Subset chromosome of interest

```{r filter gff chromosome alternative}
chromosome_gff <- genome_gff[
  genome_gff$seqnames == dpp4_chr,
]
```

We can check the source of the filtered annotations:
```{r gff_chromosome table of annotation source}
table(chromosome_gff$source)
```

Check the number of remaining genes:

```{r gff_chromosome remaining genes}
nrow(chromosome_gff)
length(unique(chromosome_gff$ID))
```

Check the summary of the upstream lengths:

```{r}
summary(chromosome_gff$upstream_length)
```



#### Subset region of interest

```{r filter gff region alternative}
region_gff <- chromosome_gff[
  chromosome_gff$start <= region_end & 
  chromosome_gff$end >= region_start, 
]
```

We can check the source of the filtered annotations:
```{r gff_region table of annotation source}
table(region_gff$source)
```

Check the number of remaining genes:

```{r gff_region remaining genes}
nrow(region_gff)
length(unique(region_gff$ID))
```

We can visualize the genes on the region of interest:

```{r gff_region plot}
# Extract relevant columns
gene_data <- region_gff[, c("strand","start", "end", "gene")]

# Create a y-axis index for unique gene names
gene_data$y_index <- match(gene_data$gene, unique(gene_data$gene))

# Set gene colors based on strand information (red for negative strand, blue for positive strand)
gene_data$gene_color <- ifelse(gene_data$strand == "-", "red", "blue")

# Set up larger plotting area and adjust margins
par(mar=c(6, 10, 4, 2), xpd=TRUE)

# Create the plot with adjusted y-axis
plot(c(min(gene_data$start), max(gene_data$end)), 
     c(0, max(gene_data$y_index) + 1), 
     type="n", 
     xlab="Genomic Coordinates", 
     ylab="", 
     xaxt="n", 
     yaxt="n")

# Plot each gene as a line, with thicker line for GeneID:101483164
for (i in 1:nrow(gene_data)) {
  # Set line width for GeneID:101483164 (2x as thick)
  lwd_value <- ifelse(gene_data$gene[i] == "LOC101483164", 4, 1)
  
  # Plot the gene line with the appropriate color and line width
  segments(gene_data$start[i], gene_data$y_index[i], gene_data$end[i], gene_data$y_index[i], 
           col=gene_data$gene_color[i], lwd=lwd_value)
}

# Add gene names to the y-axis
axis(2, at=gene_data$y_index, labels=gene_data$gene, las=1, cex.axis=0.7)
# Add x-axis with genomic coordinates
axis(1)

# Optionally, add a grid for better visualization
grid()

# Add a legend at the top-left corner
legend("topright", 
       legend=c("Positive strand (blue)", "Negative strand (red)"), 
       fill=c("blue", "red"), 
       bty="n", cex=0.8)
```

Check the summary of the upstream lengths:

```{r summary of region upstream length}
summary(region_gff$upstream_length)
```



## Step 2: Filtering of CGI by promoter overlap

CGI annotation file (`.txt` file) obtained with makeCGI v1.3.4 [@hiddenMarkov]

```{r load cgi annotation file}
# Load the CGI annotation file
cgi_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/CGI-Mzebra.txt" 
cgif <- read.table(cgi_file, header = TRUE, sep = "\t")
head(cgif)
```
Lets remove the chromosome version number from the CGI annotation:

```{r}
cgif$chr <- sub("\\.\\d+$", "", cgif$chr)
```

Check the summary of the island lengths:

```{r summary of cgi lengths}
summary(cgif$length)
```

Not all chromosomes in `genome_gff` are in the CGI annotations:

```{r}
# Identify seqnames in genome_gff that are not in cgif
missing_seqnames <- setdiff(unique(genome_gff$seqnames), unique(cgif$chr))

# Print the missing seqnames
print(missing_seqnames)
```

To check when extracting chromosome info.
```{r}
nrow(cgif[cgif$chr==missing_seqnames[1],])
```

Lets visualize the islands in the genomic region of interest:

```{r, fig.height=4, fig.width=15}
# Set up plotting area with adjusted margins
par(mfrow = c(1,1))  
par(mar=c(5, 8, 4, 4))  # Increased right margin for legend

# Create y-coordinates for each type
y_coords <- c(1, 2, 3)  # 1 for neg strand, 2 for pos strand, 3 for CGIs

# Get the x-axis range including both genes and CGIs
x_range <- range(c(region_gff$start, region_gff$end))

# Create the empty plot
plot(x_range, c(0.5, 3.5), 
     type="n", 
     xlab="Genomic Coordinates",
     ylab="",
     yaxt="n",  # Remove y-axis ticks
     main="Genes and CpG Islands")

# Add custom y-axis labels
axis(2, at=y_coords, 
     labels=c("- Strand Genes", "+ Strand Genes", "Islands"),
     las=1)  # Horizontal labels

# Plot genes on negative strand
neg_genes <- region_gff[region_gff$strand == "-", ]
for(i in 1:nrow(neg_genes)) {
    segments(neg_genes$start[i], y_coords[1], 
            neg_genes$end[i], y_coords[1],
            col="red", lwd=2)
}

# Plot genes on positive strand
pos_genes <- region_gff[region_gff$strand == "+", ]
for(i in 1:nrow(pos_genes)) {
    segments(pos_genes$start[i], y_coords[2], 
            pos_genes$end[i], y_coords[2],
            col="blue", lwd=2)
}

# Plot CGIs
region_cgis <- cgif[cgif$chr == dpp4_chr & 
                   cgif$start >= region_start & 
                   cgif$end <= region_end,]

for(i in 1:nrow(region_cgis)) {
    segments(region_cgis$start[i], y_coords[3], 
            region_cgis$end[i], y_coords[3],
            col="darkgreen", lwd=2)
}

# Add grid
grid(col="gray90")

```

For each position within each upstream region we check whether it is in a CGI and the distance to the gene.


```{r, eval = FALSE}
# Function to efficiently check if positions are within any CGI
is_within_cgi_vector <- function(positions, cgi_intervals) {
  # Apply the check for each position against all intervals
  sapply(positions, function(pos) {
    any(pos >= cgi_intervals[,1] & pos <= cgi_intervals[,2])
  })
}

# Initialize results list
#results_list <- vector("list", nrow(region_gff))
## TODO: Update comment
cgiVsDistance <- matrix(data = NA, nrow = nrow(genome_gff), ncol = 20000)

# Get the genome_gff indices for genes with a defined upstream region
nonNA_upstream <- which(!is.na(genome_gff$upstream_length))


# Set start variable for previous chromosome name
prev_chrom_name <- 0

for (i in nonNA_upstream){
  # Get current chromosome name
  chrom_name <- genome_gff$seqnames[i]
  # Get the cgi annotations for the current chromosome
  if (prev_chrom_name != chrom_name){
    chrom_cgi <- cgif[cgif$chr==chrom_name,]
    # Create a matrix of CGI intervals for faster lookup
    chrom_cgi_intervals <- cbind(chrom_cgi$start, chrom_cgi$end)
  }
  
  # Get the sequence of upstream positions
  upstream_start <- genome_gff$upstream_start[i]
  upstream_end <- genome_gff$upstream_end[i]
  if (upstream_start > upstream_end) { # Upstream in the negative strand
    positions <- seq(from = upstream_end, to = upstream_start, by = 1)
  } else { # Upstream in the positive strand
    positions <- seq(from = upstream_start, to = upstream_end, by = 1)
  }
  
  # Get CGI status for all positions at once
  in_cgi <- is_within_cgi_vector(positions, chrom_cgi_intervals)
  
  # Get the sequence of upstream distances to the gene start
  if(genome_gff$strand[i] == "+") {
    # For positive strand: distance from gene start
    distances <- genome_gff$start[i] - positions
  } else {
    # For negative strand: distance from gene end
    distances <- positions - genome_gff$end[i]
  }
  
  # Save the CGI status in the distance matrix
  cgiVsDistance[i,distances] <- in_cgi
  
  # Update the variable for the previous chromosome name
  prev_chrom_name <- chrom_name
}
```

```{r, eval=FALSE}
save(cgiVsDistance, file = "cgiVsDistance.RData")
```

```{r}
load("cgiVsDistance.RData")
```

Now we can calculate the probability of each promoter site (described by the distance to the gene) to be in a CGI:

```{r}
cgiProbByDistance <- colMeans(cgiVsDistance, na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance))
```




```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```

#### Subset chromosome of interest

```{r}
cgiProbByDistance <- colMeans(cgiVsDistance[which(genome_gff$seqnames == dpp4_chr),], na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance[which(genome_gff$seqnames == dpp4_chr),]))
```

```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```

#### Subset region of interest

```{r}
region_indeces <- genome_gff$seqnames == dpp4_chr & genome_gff$start <= region_end & genome_gff$end >= region_start
cgiProbByDistance <- colMeans(cgiVsDistance[region_indeces,], na.rm = TRUE)
distCounts <- colSums(!is.na(cgiVsDistance[region_indeces,]))
```


```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(1:length(cgiProbByDistance), cgiProbByDistance, 
     xlab = "Distance of Upstream Positions to Gene",  
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(1:length(distCounts), distCounts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(distCounts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```





# References