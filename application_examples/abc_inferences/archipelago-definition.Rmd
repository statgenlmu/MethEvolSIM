---
title: "Definition of Archipelagos"
author: "Sara"
date: "`r Sys.Date()`"
output: html_document
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning=FALSE, message=FALSE}
# If missing, install required packages

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("rtracklayer", quietly = TRUE)) {
  BiocManager::install("rtracklayer")
}


library(rtracklayer)
```

# Archipelago definition

We define archipelagos as genomic regions containing clusters of CGIs. We can interpret archipelagos as regions of the genome larger than CGI that together may regulate a gene or set of genes. Therefore, an approach to define archipelagos can be to choose thresholds that lead to clustering CGI in a way so that each archipelago overlaps with a promoter region (or maximizes cases of overlap single-archipelago and promoter).

Our approach then has the following steps:

1. Definition of promoter regions.
2. Filtering of CGI by promoter overlap.

We will perform this steps for the genomic region of interest:

```{r}
dpp4_chr <- "NC_036801.1"
dpp4_start <- 29502362
dpp4_end <- 29517382
region_start <- dpp4_start - 5e5
region_end <- dpp4_end + 5e5
```

- DPP4 gene location:

  - Chromosome: NC_036801.1
  
      - Start: 29,502,362
      
      - End: 29,517,382
        
- Extended Region: Includes 500,000 base pairs upstream and downstream of the DPP4 gene.


## Step 1: Definition of "promoter/upstream" regions

As in [@vernaz2022epigenetic], since no functional annotation exists for Lake Malawi cichlid genomes, we define promoter regions in silico as regions Â±1 kbp around the TSS.


### Choice of gene annotiation file format

File formats from [NCBI](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000238955.4/). Selected RefSeq only (no Ensembl annotation). More info [here](https://www.biobam.com/differences-between-gtf-and-gff-files-in-genomic-data-analysis/), [here](http://www.ensembl.org/info/website/upload/gff.html) and [here](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-020-6707-9). 


- The General Feature Format (GFF): GFF is a standard file format used for storing genomic sequences and annotations, developed by the Sanger Centre (v2) and the Sequence Ontology Project (v3). It describes features and annotations of DNA, RNA, and protein sequences in a plain text format with nine fields separated by tabs. Focuses on the hierarchical structure of genome annotations and is often less verbose.

- The Gene Transfer Format (GTF): GTF, often seen as a derivative of GFF, is more specific in its application. It was generally termed GTF around 2000 and developed as part of collaborative genome annotation projects. GTF borrows from GFF but has additional structures for detailed gene annotations, often used to describe transcripts and their coding sequences.

The `.gtf` file contains more information, but for our purpose we can use the `.gff` file.

```{r}
# Load the GFF file
gff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gff" 
gff <- as.data.frame(import(gff_file))

```

- `seqnames`: Chromosome.

- `start`, `end`: Coordinates of the gene.

- `strand`: Gene orientation.

- `type`: Feature type (here filtered for genes).

- `Gene`: Gene name or ID.

- `gene_biotype`: Functionality (e.g., protein_coding)


```{r}
table(gff$source)
```

- `source`: indicates the source of the annotation for each feature in the file. These sources represent the tools, pipelines, or databases that generated the corresponding annotation.

  - `RefSeq`: These annotations come directly from the RefSeq database. RefSeq annotations are high-quality, manually curated or computationally derived features that are part of NCBI's Reference Sequence project. Examples: Protein-coding genes, RNA genes, pseudogenes.

   - `Gnomon`: Gnomon is NCBI's gene prediction tool, which generates computationally predicted annotations. These annotations may include protein-coding genes, non-coding RNAs, or other features predicted based on sequence analysis. Gnomon is used when there is no manually curated annotation available for certain regions or genes.

   - `cmsearch`: This refers to the Infernal package (specifically the cmsearch tool), which identifies RNA features such as non-coding RNAs or structured RNA elements.  Often used for annotating RNA families based on covariance models.

  - `tRNAscan-SE`: tRNAscan-SE is a specialized tool for identifying and annotating tRNA genes in genome sequences. Annotations with this source indicate regions identified as tRNAs through this tool.

   - `BestRefSeq`: Features with this source are part of the BestRefSeq annotation, which integrates high-quality manual curation with computational predictions to produce a "best" annotation for a gene or transcript. BestRefSeq annotations are typically the most reliable.

  - BestRefSeq,Gnomon (or `BestRefSeq%2CGnomon`): This indicates that a feature is annotated by both the BestRefSeq and Gnomon pipelines. Such annotations may combine curated data with computational predictions.

### Filter region of interest

```{r}
region_gff <- gff[
  gff$seqnames == "NC_036801.1" & 
  gff$type == "gene" & 
  gff$start <= region_end & 
  gff$end >= region_start, 
]

head(region_gff)
```


```{r}
table(region_gff$source)
```




```{r}
region_gff[grep("GeneID:101483164", region_gff$Dbxref), ]
```

```{r}
length(unique(region_gff$ID))
unique(region_gff$ID)
```

```{r}
# Extract relevant columns
gene_data <- region_gff[, c("strand","start", "end", "gene")]

# Create a y-axis index for unique gene names
gene_data$y_index <- match(gene_data$gene, unique(gene_data$gene))

# Set gene colors based on strand information (red for negative strand, blue for positive strand)
gene_data$gene_color <- ifelse(gene_data$strand == "-", "red", "blue")

```

```{r}
# Set up larger plotting area and adjust margins
par(mar=c(6, 10, 4, 2), xpd=TRUE)

# Create the plot with adjusted y-axis
plot(c(min(gene_data$start), max(gene_data$end)), 
     c(0, max(gene_data$y_index) + 1), 
     type="n", 
     xlab="Genomic Coordinates", 
     ylab="", 
     xaxt="n", 
     yaxt="n")

# Plot each gene as a line, with thicker line for GeneID:101483164
for (i in 1:nrow(gene_data)) {
  # Set line width for GeneID:101483164 (2x as thick)
  lwd_value <- ifelse(gene_data$gene[i] == "LOC101483164", 4, 1)
  
  # Plot the gene line with the appropriate color and line width
  segments(gene_data$start[i], gene_data$y_index[i], gene_data$end[i], gene_data$y_index[i], 
           col=gene_data$gene_color[i], lwd=lwd_value)
}

# Add gene names to the y-axis
axis(2, at=gene_data$y_index, labels=gene_data$gene, las=1, cex.axis=0.7)
# Add x-axis with genomic coordinates
axis(1)

# Optionally, add a grid for better visualization
grid()

# Add a legend at the top-left corner
legend("topleft", 
       legend=c("Positive strand (blue)", "Negative strand (red)"), 
       fill=c("blue", "red"), 
       bty="n", cex=0.8)
```

```{r}
# Sort gene_data by strand and then by start position
gene_data_sorted <- gene_data[order(gene_data$strand, gene_data$start), ]

# Initialize a vector to store overlap results
gene_data_sorted$overlap <- FALSE

# Loop over genes, comparing each gene with the next one in the same strand
for (i in 1:(nrow(gene_data_sorted) - 1)) {
  # Check if genes are on the same strand and overlap
  if (gene_data_sorted$strand[i] == gene_data_sorted$strand[i + 1] &&
      gene_data_sorted$end[i] >= gene_data_sorted$start[i + 1]) {
    gene_data_sorted$overlap[i] <- TRUE
    gene_data_sorted$overlap[i + 1] <- TRUE
  }
}

# View the genes with overlap information
head(gene_data_sorted)

```

```{r}
gene_data_sorted[which(gene_data_sorted$overlap==TRUE),"gene"]
```

```{r}
region_gff[region_gff$gene == "nop58",]
region_gff[region_gff$gene == "LOC111501074",]
```

The second one corresponds to the source `cmsearch`, so it may be the one that should be taken out.


```{r}
region_gff <- region_gff[region_gff$gene != "LOC111501074",]
```


### Define the 200 kb upstream regions




Calculate the upstream start and end to prevent overlap with the previous gene. *This is done for each strand from the second gene onwards as we dont know where the gene before the first gene is as it is not included in the region dataframe*.

- For genes on the positive strand, the upstream region starts 20kb before the gene's start position, or at the end of the previous gene if there is one.

- For genes on the negative strand, the upstream region starts 20kb after the gene's end position, or at the start of the next gene if there is one.


```{r}
# Separate genes by strand
positive_strand_genes <- region_gff[region_gff$strand == "+", ]
negative_strand_genes <- region_gff[region_gff$strand == "-", ]

# Sort genes by start position within each strand
positive_strand_genes <- positive_strand_genes[order(positive_strand_genes$start), ]
negative_strand_genes <- negative_strand_genes[order(negative_strand_genes$end, decreasing = TRUE), ]

# Initialize the new columns for upstream start and end
positive_strand_genes$upstream_start <- NA
positive_strand_genes$upstream_end <- NA

negative_strand_genes$upstream_start <- NA
negative_strand_genes$upstream_end <- NA

# Calculate the upstream region for positive strand genes
for (i in 2:nrow(positive_strand_genes)) {
  positive_strand_genes$upstream_start[i] <- max(positive_strand_genes$start[i] - 20000, positive_strand_genes$end[i-1] + 1)
  positive_strand_genes$upstream_end[i] <- positive_strand_genes$start[i] - 1
}

# Calculate the upstream region for negative strand genes
for (i in 2:nrow(negative_strand_genes)) {
  negative_strand_genes$upstream_start[i] <- min(negative_strand_genes$end[i] + 20000, negative_strand_genes$start[i-1] - 1)
  negative_strand_genes$upstream_end[i] <- negative_strand_genes$end[i] + 1
}

# Combine the results back
region_gff <- rbind(positive_strand_genes, negative_strand_genes)

# View the updated dataframe with upstream regions
head(region_gff)

```


#### Chromosome lengths

In case the upstream regions were to be defined for all chromosomes/scaffolds, the chromosome lengths would be needed to be the maximum for the start of the upstream region of the genes on the negative strand.

Load chromosome lengths:

```{r, eval = FALSE}
gbff_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/ncbi_dataset/ncbi_dataset/data/GCF_000238955.4/genomic.gbff" 
file_lines <- readLines(gbff_file)
# Extract the LOCUS line
locus_lines <- file_lines[grep("^LOCUS", file_lines)]
head(locus_lines)
```

They don't seem to end with the dot and the number (version) as in the case of the `gff` data. Lets check if the `gff` has several versions:

```{r}
length(unique(gff$seqnames))
# Remove version suffix from seqnames
length(unique(sub("\\.\\d+$", "", gff$seqnames)))
```

It does not have several versions.

```{r, eval = FALSE}
# Extract chromosome names and lengths
chrom_info <- gsub("^LOCUS\\s+(\\S+)\\s+(\\d+)\\s+.*$", "\\1,\\2", locus_lines)
chrom_info <- strsplit(chrom_info, ",")
chrom_names <- sapply(chrom_info, `[`, 1)
chrom_lengths <- as.numeric(sapply(chrom_info, `[`, 2))
# Create a named vector
chrom_lengths <- setNames(chrom_lengths, chrom_names)

# Remove version numbers from seqnames in the region-filtered gff
region_gff$seqnames <- sub("\\.\\d+$", "", region_gff$seqnames)

```




## Step 2: Filtering of CGI by promoter overlap

CGI annotation file (`.txt` file) obtained with makeCGI v1.3.4 [@hiddenMarkov]

```{r}
# Load the CGI annotation file
cgi_file <- "/home/sara/methylation/MethEvolSIM/application_examples/abc_inferences/genomic_dist/CGI-Mzebra.txt" 
cgif <- read.table(cgi_file, header = TRUE, sep = "\t")
head(cgif)
```

```{r}
region_cgi <- cgif[cgif$chr==dpp4_chr,]
```

```{r}
# Create a matrix of CGI intervals for faster lookup
cgi_intervals <- cbind(region_cgi$start, region_cgi$end)

# Function to efficiently check if positions are within any CGI
is_within_cgi_vector <- function(positions, cgi_intervals) {
  # Apply the check for each position against all intervals
  sapply(positions, function(pos) {
    any(pos >= cgi_intervals[,1] & pos <= cgi_intervals[,2])
  })
}

# Initialize results list for better memory management
results_list <- vector("list", nrow(region_gff))

# Process each gene
for (i in 1:nrow(region_gff)) {
  upstream_start <- region_gff$upstream_start[i]
  upstream_end <- region_gff$upstream_end[i]
  
  # Skip if NA values
  if (is.na(upstream_start) | is.na(upstream_end)) {
    next
  }
  
  # Create sequence of positions (handling both forward and reverse cases)
  if (upstream_start > upstream_end) {
    positions <- seq(from = upstream_start, to = upstream_end, by = -1)
  } else {
    positions <- seq(from = upstream_start, to = upstream_end, by = 1)
  }
  
  # Get CGI status for all positions at once
  in_cgi <- is_within_cgi_vector(positions, cgi_intervals)
  
  # Calculate distances properly based on strand
  distances <- if(region_gff$strand[i] == "+") {
    # For positive strand: distance from gene start
    region_gff$start[i] - positions  # Positive values will be upstream
  } else {
    # For negative strand: distance from gene end
    positions - region_gff$end[i]    # Positive values will be upstream
  }
  
  # Create result data frame for this gene
  results_list[[i]] <- data.frame(
    gene_id = region_gff$gene[i],
    position = positions,
    in_cgi = in_cgi,
    distance = distances,
    strand = region_gff$strand[i]
  )
}

# Combine all results efficiently
upstream_data <- do.call(rbind, results_list[!sapply(results_list, is.null)])

# Calculate counts and probabilities
position_counts <- table(upstream_data$distance)  # Using table() for correct counts
distance_seq <- as.numeric(names(position_counts))

# Calculate probabilities
cgi_probabilities <- tapply(upstream_data$in_cgi, 
                          upstream_data$distance, 
                          mean)   # Probability of being in CGI


```

```{r, fig.height=12, fig.width=10}
# Set up the plot with better formatting
par(mfrow = c(2,1))  # Set up 2 plots vertically
par(mar = c(4, 5, 4, 2))  # Adjust margins for top plot
# Plot 1: Probability plot
plot(distance_seq, cgi_probabilities, 
     xlab = "",  # Remove x-label from top plot
     ylab = "Probability of Position Being in CGI",
     main = "Probability of Position Being in CpG Island\nby Distance to Gene Start",
     cex.lab = 1.2,      # Larger axis labels
     cex.axis = 1.1,     # Larger axis numbers
     cex.main = 1.3,     # Larger title
     las = 1,            # Horizontal axis labels
     pch = 16,          # Solid circle points
     ylim = c(0, 1),    # Force probability y-axis to [0,1]
     col = adjustcolor("darkblue", alpha.f = 0.5))  # Semi-transparent blue

# Add grid
grid(col = "gray90", lty = "dotted")

# Add a horizontal line at y = 0
abline(h = 0, col = "gray70", lty = 2)

# Plot 2: Count plot
par(mar = c(5, 5, 3, 2))  # Adjust margins for bottom plot
plot(distance_seq, position_counts, type = "h",  # Using the correct counts
     xlab = "Distance to Gene Start (bp)",
     ylab = "Number of Positions",
     main = "Number of Positions at Each Distance",
     col = "darkgreen",
     lwd = 1,
     ylim = c(0, max(position_counts) * 1.05))  # Force y-axis to start at 0 with 5% padding
grid(col = "gray90", lty = "dotted")
```


```{r, fig.height=4, fig.width=15}
# Set up plotting area with adjusted margins
par(mfrow = c(1,1))  
par(mar=c(5, 8, 4, 4))  # Increased right margin for legend

# Create y-coordinates for each type
y_coords <- c(1, 2, 3)  # 1 for neg strand, 2 for pos strand, 3 for CGIs

# Get the x-axis range including both genes and CGIs
x_range <- range(c(region_gff$start, region_gff$end))

# Create the empty plot
plot(x_range, c(0.5, 3.5), 
     type="n", 
     xlab="Genomic Coordinates",
     ylab="",
     yaxt="n",  # Remove y-axis ticks
     main="Genes and CpG Islands")

# Add custom y-axis labels
axis(2, at=y_coords, 
     labels=c("- Strand Genes", "+ Strand Genes", "Islands"),
     las=1)  # Horizontal labels

# Plot genes on negative strand
neg_genes <- region_gff[region_gff$strand == "-", ]
for(i in 1:nrow(neg_genes)) {
    segments(neg_genes$start[i], y_coords[1], 
            neg_genes$end[i], y_coords[1],
            col="red", lwd=2)
}

# Plot genes on positive strand
pos_genes <- region_gff[region_gff$strand == "+", ]
for(i in 1:nrow(pos_genes)) {
    segments(pos_genes$start[i], y_coords[2], 
            pos_genes$end[i], y_coords[2],
            col="blue", lwd=2)
}

# Plot CGIs
region_cgis <- cgif[cgif$chr == dpp4_chr & 
                   cgif$start >= region_start & 
                   cgif$end <= region_end,]

for(i in 1:nrow(region_cgis)) {
    segments(region_cgis$start[i], y_coords[3], 
            region_cgis$end[i], y_coords[3],
            col="darkgreen", lwd=2)
}

# Add grid
grid(col="gray90")

```

# References