---
title: "ABC inferences"
output: 
  rmarkdown::html_vignette:
    toc: true
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{ABC Inferences with MethEvolSIM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,  # Set the figure width to match the text width
  fig.height = 5, # Set the figure height
  out.width = "100%"  # Ensure it takes up 100% of the available width in HTML
)
```

```{r, echo=FALSE}
## TODO: Update 
library(devtools)
load_all()
```

# Workflow dependencies

Are listed under the file `environment.yaml`. Before running the workflow, a conda environment can be created with:

```{bash, eval = FALSE}
conda env create -n abc_inferences -f environment.yaml
```

I got error with:

- `r-parallel`         # parallel for R

But it can be alternativelly installed by:

```{bash, eval = FALSE}
conda activate abc_inferences
R
install.packages("parallel")
## Another package it is still dependent on is
install.packages("devtools")
```


Then, the workflow can be run by:

```{bash, eval = FALSE}
conda activate abc_inferences
snakemake --use-conda
```

I also got the following error when trying to run the rule `run_sim`:

```{bash, eval = FALSE}
Conda must be version 24.7.1 or later, found version 22.11.1. Please update conda to the latest version. Note that you can also install conda into the snakemake environment without modifying your main conda installation.
# Then I tried to install conda into the snakemake environment with
conda activate abc_inferences
(abc_inferences) saracv@australia:~/MasterThesis/MethEvolSIM/extensive_tests/abc_inferences$ conda install conda=24.11.0                                                                                                                      
Collecting package metadata (current_repodata.json): done                                                                                                                                                                                 
Solving environment: done                                                                                                                                                                                                              
==> WARNING: A newer version of conda exists. <==                                                                                                                          
  current version: 22.11.1                                                                                                               
  latest version: 24.11.0                                                                                                                                                                                                     
Please update conda by running                                                                                                                                                                                                           
    $ conda update -n base -c conda-forge conda                                                                                                                                                                                          
Or to minimize the number of packages updated during conda update use                                                                                                                                                                         
     conda install conda=24.11.0

# All requested packages already installed.

(abc_inferences) saracv@australia:~/MasterThesis/MethEvolSIM/extensive_tests/abc_inferences$ conda --version
conda 22.11.1

```

**This does not seem to work. I tried it out with**:

```{bash, eval = FALSE}
conda activate snakemake
nohup nice snakemake --use-conda run_sim > run_sim.out &
```

and seems to be stuck in:

```{bash, eval = FALSE}
cat run_sim.out 
Injecting conda environment /home/saracv/MasterThesis/MethEvolSIM/extensive_tests/abc_inferences/environment.yaml.
```

**IMPORTANT: BOTH HERE AND IN CFTP ENVIRONMENT.YAML BEFORE SUBMITTING CHANGE DEVTOOLS BY METHEVOLSIM**


# Selection of genomic region(s)


-Requires: CGI annotation file (`.txt` file) obtained with makeCGI v1.3.4 [@hiddenMarkov]

- The genome assembly file: Obtain the FASTA file ([GCF_000238955.4_M_zebra_UMD2a_genomic.fa](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000238955.4/)) from NCBI (file source *RefSeq*, file type *Genome Sequences (FASTA)*)

Both under subdirectory genomic_dist

```{r}
# Load data
file_path <- "genomic_dist/CGI-Mzebra.txt" # Adjust the path if necessary
cgi_data <- read.table(file_path, header = TRUE, sep = "\t")

# View the first lines
head(cgi_data)
# View the last lines
tail(cgi_data)
```

The prefixes `NC_` and `NW_` in chromosome or genomic sequence identifiers come from the RefSeq database and indicate different types of assembly or annotation status for genomic sequences:

- `NC_` refers to non-redundant complete genomic molecules, which typically represent well-characterized, curated, and assembled sequences.

- `NW_` refers to scaffolds or unplaced sequences that are part of the genome assembly but cannot yet be confidently assigned to a specific chromosome or region.


```{r}
# Count the number of CGIs per chromosome
cgi_count <- table(cgi_data$chr)

# View results grouped by type of chromosome assembly

# Split into groups based on chromosome prefix
groups <- ifelse(grepl("^NC_", names(cgi_count)), "NC", "NW")

# Create a dataframe
cgi_data <- data.frame(
  group = groups,
  count = as.numeric(cgi_count)
)

# Plot boxplots
boxplot(count ~ group, data = cgi_data,
        col = c("skyblue", "salmon"),
        main = "Distribution of Counts for NC_ and NW_ Chromosomes",
        xlab = "Chromosome Type",
        ylab = "Counts")

```

## Fixed DMR found in paper: Associated genes

Add reference

- *Smad4a*: LOC101481185. Fixed but not associated with differential expression.

Genes reported as fixed DMR with significant transcriptional downregulation in benthic livers and associated with fixed benthic-specific hypermethylated levels at their promoters, suggesting retained epigenetic divergence associated with different diets. 

- *Dpp4*: Part of the insulin methabolic pathway. Location according to NCBI annotation release 104 (LOC101483164): NC_036801.1 (29502362..29517382) 

- *Ces2*: Liver carboxylesterase 2, part of the fatty acid methabolic pathway. Location according to NCBI annotation release 104 (LOC101473569):  	NW_020192811.1 (49164..53741, complement) 

Lets explore *Dpp4*, as it is associated with differential gene expression and it is located in a better characterized genomic region:

```{r}
dpp4_chr <- "NC_036801.1"
dpp4_start <- 29502362
dpp4_end <- 29517382
```


## Explore the CpG counts in islands and non islands generated from the reference genome and the CGI annotation


```{r}
load("genomic_dist/CpG_count.RData")
```


```{r}
# Filter the data for the given chromosome and region
filtered_data <- CpG_count[CpG_count$chr == dpp4_chr & CpG_count$start >= dpp4_start - 5e5 & CpG_count$start <= dpp4_end + 5e5, ]

# Set up the plot area
plot(filtered_data$start, filtered_data$CpG_count, 
     type = "n", # No points, just the axis
     xlab = "Position (bp)", ylab = "CpG Count", 
     main = "CpG Count by Island/Non-Island Regions", 
     xlim = c(min(filtered_data$start), max(filtered_data$end)), 
     ylim = c(0, max(filtered_data$CpG_count) * 1.1))

# Add bars with color based on 'str' (island vs non-island)
for (i in 1:nrow(filtered_data)) {
  # Calculate the width of each region (difference between start and end)
  region_width <- filtered_data$end[i] - filtered_data$start[i]
  
  if (filtered_data$str[i] == "Non-island") {
    # Non-island (blue)
    rect(filtered_data$start[i], 0, filtered_data$end[i], 
         filtered_data$CpG_count[i], col = "blue", border = "blue")
  } else {
    # Island (red)
    rect(filtered_data$start[i], 0, filtered_data$end[i], 
         filtered_data$CpG_count[i], col = "red", border = "red")
  }
}

# Add vertical lines showing where the gene is
abline(v = dpp4_start)
abline(v = dpp4_end)


# Add a legend
legend("topright", legend = c("Non-Island", "Island"), 
       fill = c("blue", "red"), title = "Island Type")

```

Genomic region close to gene *dpp4*. X-axis corresponds to the positions in chromosome `r dpp4_chr`. Y-axis corresponds to CpG counts at each genomic region. Each genomic region is represented by a bar starting and ending in the corresponding chromosome position. Vertical black lines represent start and end of gene *dpp4*.


```{r}

# Filter the data for the given chromosome and region
filtered_data <- CpG_count[CpG_count$chr == dpp4_chr & CpG_count$start > dpp4_start - 5e5 & CpG_count$end < dpp4_end + 5e5, ]

# Calculate the CpG density for each region (CpG count / region length)
filtered_data$CpG_density <- filtered_data$CpG_count / (filtered_data$end - filtered_data$start)

# Plot CpG density vs. position (using 'start' as x-axis)

# Set up the plot area with no points initially
plot(filtered_data$start, filtered_data$CpG_density, 
     type = "n", # No points, just the axis
     xlab = "Position (bp)", ylab = "CpG Density", 
     main = "CpG Density by Island/Non-Island Regions", 
     xlim = c(min(filtered_data$start), max(filtered_data$end)), 
     ylim = c(0, max(filtered_data$CpG_density) * 1.1))

# Add points colored by 'str' (0 for non-island, 1 for island)
points(filtered_data$start, filtered_data$CpG_density, 
       col = ifelse(filtered_data$str == "Island", "red", "blue"), 
       pch = 16)  # pch=16 gives filled circles

# Add vertical lines showing where the gene is
abline(v = dpp4_start)
abline(v = dpp4_end)

# Add a legend
legend("topright", legend = c("Non-Island", "Island"), 
       fill = c("blue", "red"), title = "Type")


```

Genomic region close to gene *dpp4*. X-axis corresponds to the positions in chromosome `r dpp4_chr`. Y-axis corresponds to CpG density at each genomic region. Each genomic region is represented by a dot at its corresponding genome start position. Vertical black lines represent start and end of gene *dpp4*.

When using this region the number of CpG sites to simulate would be:

```{r}
sum(filtered_data$CpG_count)
```

with number of non-island and island structures:

```{r}
# Count the number of occurrences of each factor level in the 'str' column
table(filtered_data$str)
```



# Worflow for simulation-based inferences

This workflow uses [Snakemake](https://snakemake.readthedocs.io) to manage the steps for simulating DNA methylation patterns, assessing ABC accuracy, and inferring model parameters.

## Requirements

- Snakemake installed (`conda create -c conda-forge -c bioconda -n snakemake snakemake`)

- R packages: optparse (add to dependencies), parallel, ape

- Access to the provided `Snakefile` and associated scripts.

- An .RData file with a dataframe specifying the distribution of methylation sites in the genomic region.

- An .RData file with a tree in ape format (TODO: modify this and check whether scrm is also producing trees in the same format)

## Steps in the Workflow

1. Set the output directory.

2. Get the CpG count in islands and non-island regions relative to the reference genome.

3. Filter the CpG count in islands and non-island regions for the genomic region of interest.

4. Get the spatial structure dataframe from the filtered GpG count to use as input for the simulations.

5. Save as simulation design the genomic structure for the regions within the selected genomic region, tree(s) -- GIVEN -- and sampled parameter combinations.

6. Run the simulations. TODO: Before submitting load package without devtools

7. Get the CpG position indices relative to the reference genome (cytosine index relative to positive strand).

8. Filter the CpG position indices within the genomic region of interest.

9. Compute the selected summary statistics. TODO: When added sumStats functions to package, stop sourcing script.

10. Assess ABC accuracy using cross-validation.

11. Infer parameters from empirical DNA methylation data.


# Choice of parameters according to region of interest

## Shore length and min number of CpGs

```{r}
# load the spatial distribution of sites in islands and non-islands for the
# region of interest
load("NC_036801.1_29002362_30002362_dpp4.RData")
```

```{r}
# Add a column to keep the original structure index after subsetting
spatial_str$str_index <- 1:dim(spatial_str)[1]
# Subset islands and non islands
islands <- spatial_str[spatial_str$globalState == "U",]
nonislands <- spatial_str[spatial_str$globalState == "M",]
```

Number of islands and non-islands in the region of interest:

```{r}
island_n <- dim(islands)[1]
nonisland_n <- dim(nonislands)[1]
island_n
nonisland_n
```

Summary of the number of sites at each island and non-island structure

```{r}
summary(islands$n)
summary(nonislands$n)
```

```{r}
# Combine data into a list
boxplot_data <- list(Islands = islands$n, NonIslands = nonislands$n)

# Create the boxplot
boxplot(boxplot_data, 
        main = "Distribution of n in Islands and Non-Islands",
        ylab = "n",
        col = c("lightblue", "lightcoral"))

```

```{r}
load("design.RData")
```

```{r}
iota <- sampled_params[1, "iota"]
iota
```

```{r}
load("abc_dataSIM_000001.RData")
```


```{r}
index_islands <- which(spatial_str$globalState == "U")
index_nonislands <- which(spatial_str$globalState == "M")
shore_length <- 10
minN_CpG <- 5
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
```

```{r}
shore_length <- 5
minN_CpG <- 5
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
```
```{r}
shore_length <- 5
minN_CpG <- 10
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 5
minN_CpG <- 15
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 10
minN_CpG <- 10
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 10
minN_CpG <- 20
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
iota <- sampled_params[6, "iota"]
iota
```

```{r}
load("abc_dataSIM_000006.RData")
```


```{r}
index_islands <- which(spatial_str$globalState == "U")
index_nonislands <- which(spatial_str$globalState == "M")
shore_length <- 10
minN_CpG <- 5
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
```

```{r}
shore_length <- 5
minN_CpG <- 5
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
```
```{r}
shore_length <- 5
minN_CpG <- 10
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 5
minN_CpG <- 15
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 10
minN_CpG <- 10
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

```{r}
shore_length <- 10
minN_CpG <- 15
print(paste("Number of islands considered out of:", island_n))
dim(islands[islands$n >= shore_length + minN_CpG,])[1]
print("MeanCor islands")
compute_meanCor_i(index_islands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("Number of non-islands considered out of:", nonisland_n))
dim(nonislands[nonislands$n >= shore_length + minN_CpG,])[1]
print("MeanCor non-islands")
compute_meanCor_ni(index_nonislands, minN_CpG, shore_length, data, sample_n = 3)
print(paste("iota:", iota))
```

Seems that the combination leading to higher MeanCor values while still including some islands could be shore_length 5, minN_CpG 15 (keeps 9 islands). Lets see the borders in the data

```{r}
shore_length <- 5
minN_CpG <- 15
kept_islands <- islands[which(islands$n >= shore_length + minN_CpG), "str_index"]
for(tip in 1:3){
  for(i in 1:length(kept_islands)){
    print(data[[tip]][[kept_islands[i]]])
  }
}

```



## u and m thresholds

```{r}
load("mean_Meth_islands.RData")
```

```{r}
# Extract all methylation values into a single vector
all_values <- unlist(mean_Meth_islands)

# Plot density
plot(density(all_values, na.rm = TRUE), 
     main = "Density of Mean Methylation Values at Islands", 
     xlab = "Mean Methylation", 
     col = "blue", lwd = 2)

```

```{r}
summary(all_values)
```



```{r}
# Initialize an empty list to store results
changes_list <- list()

# Loop through each simulation
for (i in seq_along(mean_Meth_islands)) {
  
  # Extract values for the three tips
  tip1 <- mean_Meth_islands[[i]][[1]]
  tip2 <- mean_Meth_islands[[i]][[2]]
  tip3 <- mean_Meth_islands[[i]][[3]]
  
  # Ensure all vectors are the same length
  n <- length(tip1)  # Assuming tip1, tip2, tip3 are of equal length
  
  # Create a data frame for changes between tips
  changes_list[[i]] <- data.frame(
    index = rep(index[i], 3 * n), # Repeat index for all comparisons
    tip_from = rep(c(1, 1, 2), each = n), # Tip of origin
    tip_to = rep(c(2, 3, 3), each = n), # Tip of destination
    meanMeth_from = c(tip1, tip1, tip2),
    meanMeth_to = c(tip2, tip3, tip3),
    meanMeth_diff = c(tip2 - tip1, tip3 - tip1, tip3 - tip2)
  )
}

# Combine all changes into a single data frame
changes_df <- do.call(rbind, changes_list)

# Print the first few rows
head(changes_df[changes_df$meanMeth_diff != 0,])
```

```{r}
# Filter cases where meanMeth_diff is not zero
changes_nonzero <- changes_df[changes_df$meanMeth_diff != 0, ]

# Plot histogram
plot(density(abs(changes_nonzero$meanMeth_diff)), 
     breaks = 30, 
     col = "lightblue", 
     main = "Distribution of meanMeth_diff (Non-Zero Changes)", 
     xlab = "Methylation Difference",
     border = "black")

```

```{r}
changes_nonzero$meanMeth_diff <- abs(changes_nonzero$meanMeth_diff)
summary(changes_nonzero$meanMeth_diff)
```

```{r}
head(changes_nonzero[order(changes_nonzero$meanMeth_diff), "meanMeth_diff"])
```

```{r}
changes_overFirstQuantile <- changes_nonzero[changes_nonzero$meanMeth_diff > 0.08333,]
head(changes_overFirstQuantile[order(changes_overFirstQuantile$meanMeth_diff),])
```

Lets see how the current summary statistics behave, taking into account that it will not capture most of the global methylation changes as they the state at the different tips will fall under the same category. E.g. for index 12 tip 1 shows 0.58 and tip 2 and 3 have the same value 0.66. Both tips will be categorized as partially methylated but this looks like an IWE. 

# Sumstats before debug exploration

```{r}
load("merged_sumStats.RData")
load("design.RData")
```

```{r}
# Subset parameter combinations in output files
subset_params <- sampled_params[as.integer(rownames(merged_sumStats)),]
```

```{r}
par(mfrow = c(1,2))
plot(subset_params$iota, merged_sumStats$meanCor_i,
     xlab = "iota", ylab = "meanCor",
     main = "Island")
plot(subset_params$iota, merged_sumStats$meanCor_ni,
     xlab = "iota", ylab = "meanCor",
     main = "Non-island")
```

For this I used as thresholds a minimum number of CpGs of 15 and shore length 5. It was then only considering 9 islands. Still in non islands it shows a decreasing trend. However in the test for CFTP convergence CFTP with higher iota was leading to larger mean correlation values (there all islands and non-islands were considered, as the number of sites per structure was fixed to 100 (and 20 islands and 20 non-islands) and 10 sites was the shore lengthä)


```{r}
merged_sumStats$meanCor_i[which(subset_params$iota == min(subset_params$iota))]
```

```{r}
plot(subset_params$mu, merged_sumStats$Fitch_islandGlbSt,
     xlab = "mu", ylab = "Fitch",
     main = "Island")
```


```{r}
names(subset_params)[12] <- "TMRCA_smallestCherry"
par(mfrow = c(1,2))
plot(subset_params$TMRCA_smallestCherry, merged_sumStats$MeanSiteFChange_i,
     xlab = "TMRCA_smallestCherry", ylab = "MeanSiteFChange",
     main = "Island")
plot(subset_params$TMRCA_smallestCherry, merged_sumStats$MeanSiteFChange_ni,
     xlab = "TMRCA_smallestCherry", ylab = "MeanSiteFChange",
     main = "Non-island")
```



# References

